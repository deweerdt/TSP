/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "tsp_rpc.h"

bool_t
xdr_TSP_status_t (XDR *xdrs, TSP_status_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_session_state_t (XDR *xdrs, TSP_session_state_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_datatype_t (XDR *xdrs, TSP_datatype_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_open_t (XDR *xdrs, TSP_answer_open_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_TSP_status_t (xdrs, &objp->status))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->status_str, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_argv_item_t (XDR *xdrs, TSP_argv_item_t *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, objp, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_argv_t (XDR *xdrs, TSP_argv_t *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->TSP_argv_t_val, (u_int *) &objp->TSP_argv_t_len, ~0,
		sizeof (TSP_argv_item_t), (xdrproc_t) xdr_TSP_argv_item_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_open_t (XDR *xdrs, TSP_request_open_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_TSP_argv_t (xdrs, &objp->argv))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_close_t (XDR *xdrs, TSP_request_close_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_information_t (XDR *xdrs, TSP_request_information_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_feature_t (XDR *xdrs, TSP_request_feature_t *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (2 +  4 )* BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->version_id);
			IXDR_PUT_U_LONG(buf, objp->channel_id);
			{
				register u_int *genp;

				for (i = 0, genp = objp->feature_words;
					i < 4; ++i) {
					IXDR_PUT_U_LONG(buf, *genp++);
				}
			}
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (2 +  4 )* BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
		} else {
			objp->version_id = IXDR_GET_LONG(buf);
			objp->channel_id = IXDR_GET_U_LONG(buf);
			{
				register u_int *genp;

				for (i = 0, genp = objp->feature_words;
					i < 4; ++i) {
					*genp++ = IXDR_GET_U_LONG(buf);
				}
			}
		}
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_feature_t (XDR *xdrs, TSP_answer_feature_t *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->int_value))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->version_id);
		IXDR_PUT_U_LONG(buf, objp->channel_id);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				IXDR_PUT_U_LONG(buf, *genp++);
			}
		}
		IXDR_PUT_LONG(buf, objp->int_value);
		}
		 if (!xdr_double (xdrs, &objp->double_value))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->string_value, ~0))
			 return FALSE;
		 if (!xdr_TSP_status_t (xdrs, &objp->status))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->int_value))
				 return FALSE;

		} else {
		objp->version_id = IXDR_GET_LONG(buf);
		objp->channel_id = IXDR_GET_U_LONG(buf);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				*genp++ = IXDR_GET_U_LONG(buf);
			}
		}
		objp->int_value = IXDR_GET_LONG(buf);
		}
		 if (!xdr_double (xdrs, &objp->double_value))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->string_value, ~0))
			 return FALSE;
		 if (!xdr_TSP_status_t (xdrs, &objp->status))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->int_value))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->double_value))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->string_value, ~0))
		 return FALSE;
	 if (!xdr_TSP_status_t (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_exec_feature_t (XDR *xdrs, TSP_exec_feature_t *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->int_value))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->version_id);
		IXDR_PUT_U_LONG(buf, objp->channel_id);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				IXDR_PUT_U_LONG(buf, *genp++);
			}
		}
		IXDR_PUT_LONG(buf, objp->int_value);
		}
		 if (!xdr_double (xdrs, &objp->double_value))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->string_value, ~0))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->int_value))
				 return FALSE;

		} else {
		objp->version_id = IXDR_GET_LONG(buf);
		objp->channel_id = IXDR_GET_U_LONG(buf);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				*genp++ = IXDR_GET_U_LONG(buf);
			}
		}
		objp->int_value = IXDR_GET_LONG(buf);
		}
		 if (!xdr_double (xdrs, &objp->double_value))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->string_value, ~0))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->int_value))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->double_value))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->string_value, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_sample_symbol_info_t (XDR *xdrs, TSP_sample_symbol_info_t *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->provider_global_index))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_index))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_rank))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->provider_global_index);
		IXDR_PUT_LONG(buf, objp->provider_group_index);
		IXDR_PUT_LONG(buf, objp->provider_group_rank);
		}
		 if (!xdr_TSP_datatype_t (xdrs, &objp->type))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->dimension))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->offset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nelem))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->period))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->phase))
				 return FALSE;
		} else {
			IXDR_PUT_U_LONG(buf, objp->dimension);
			IXDR_PUT_U_LONG(buf, objp->offset);
			IXDR_PUT_U_LONG(buf, objp->nelem);
			IXDR_PUT_LONG(buf, objp->period);
			IXDR_PUT_LONG(buf, objp->phase);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_string (xdrs, &objp->name, ~0))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->provider_global_index))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_index))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_rank))
				 return FALSE;

		} else {
		objp->provider_global_index = IXDR_GET_LONG(buf);
		objp->provider_group_index = IXDR_GET_LONG(buf);
		objp->provider_group_rank = IXDR_GET_LONG(buf);
		}
		 if (!xdr_TSP_datatype_t (xdrs, &objp->type))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 5 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_u_int (xdrs, &objp->dimension))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->offset))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nelem))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->period))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->phase))
				 return FALSE;
		} else {
			objp->dimension = IXDR_GET_U_LONG(buf);
			objp->offset = IXDR_GET_U_LONG(buf);
			objp->nelem = IXDR_GET_U_LONG(buf);
			objp->period = IXDR_GET_LONG(buf);
			objp->phase = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_string (xdrs, &objp->name, ~0))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->provider_global_index))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->provider_group_index))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->provider_group_rank))
		 return FALSE;
	 if (!xdr_TSP_datatype_t (xdrs, &objp->type))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->dimension))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->nelem))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->period))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->phase))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_sample_symbol_info_list_t (XDR *xdrs, TSP_sample_symbol_info_list_t *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->TSP_sample_symbol_info_list_t_val, (u_int *) &objp->TSP_sample_symbol_info_list_t_len, ~0,
		sizeof (TSP_sample_symbol_info_t), (xdrproc_t) xdr_TSP_sample_symbol_info_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_extended_info_t (XDR *xdrs, TSP_extended_info_t *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->key, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->value, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_extended_info_list_t (XDR *xdrs, TSP_extended_info_list_t *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->TSP_extended_info_list_t_val, (u_int *) &objp->TSP_extended_info_list_t_len, ~0,
		sizeof (TSP_extended_info_t), (xdrproc_t) xdr_TSP_extended_info_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_sample_symbol_extended_info_t (XDR *xdrs, TSP_sample_symbol_extended_info_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->provider_global_index))
		 return FALSE;
	 if (!xdr_TSP_extended_info_list_t (xdrs, &objp->info))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_sample_symbol_extended_info_list_t (XDR *xdrs, TSP_sample_symbol_extended_info_list_t *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->TSP_sample_symbol_extended_info_list_t_val, (u_int *) &objp->TSP_sample_symbol_extended_info_list_t_len, ~0,
		sizeof (TSP_sample_symbol_extended_info_t), (xdrproc_t) xdr_TSP_sample_symbol_extended_info_t))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_extended_information_t (XDR *xdrs, TSP_request_extended_information_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->pgi.pgi_val, (u_int *) &objp->pgi.pgi_len, ~0,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_extended_information_t (XDR *xdrs, TSP_answer_extended_information_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_TSP_sample_symbol_extended_info_list_t (xdrs, &objp->extsymbols))
		 return FALSE;
	 if (!xdr_TSP_status_t (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_sample_t (XDR *xdrs, TSP_request_sample_t *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->consumer_timeout))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->version_id);
		IXDR_PUT_U_LONG(buf, objp->channel_id);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				IXDR_PUT_U_LONG(buf, *genp++);
			}
		}
		IXDR_PUT_LONG(buf, objp->consumer_timeout);
		}
		 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (3 + ( 4 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
				sizeof (u_int), (xdrproc_t) xdr_u_int))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->consumer_timeout))
				 return FALSE;

		} else {
		objp->version_id = IXDR_GET_LONG(buf);
		objp->channel_id = IXDR_GET_U_LONG(buf);
		{
			register u_int *genp;

			for (i = 0, genp = objp->feature_words;
				i < 4; ++i) {
				*genp++ = IXDR_GET_U_LONG(buf);
			}
		}
		objp->consumer_timeout = IXDR_GET_LONG(buf);
		}
		 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->feature_words, 4,
		sizeof (u_int), (xdrproc_t) xdr_u_int))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->consumer_timeout))
		 return FALSE;
	 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_sample_t (XDR *xdrs, TSP_answer_sample_t *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_timeout))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_number))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->version_id);
		IXDR_PUT_U_LONG(buf, objp->channel_id);
		IXDR_PUT_LONG(buf, objp->provider_timeout);
		IXDR_PUT_LONG(buf, objp->provider_group_number);
		}
		 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->base_frequency))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->max_period))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->max_client_number))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->current_client_number))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->max_period);
		IXDR_PUT_LONG(buf, objp->max_client_number);
		IXDR_PUT_LONG(buf, objp->current_client_number);
		}
		 if (!xdr_TSP_status_t (xdrs, &objp->status))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->version_id))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->channel_id))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_timeout))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->provider_group_number))
				 return FALSE;

		} else {
		objp->version_id = IXDR_GET_LONG(buf);
		objp->channel_id = IXDR_GET_U_LONG(buf);
		objp->provider_timeout = IXDR_GET_LONG(buf);
		objp->provider_group_number = IXDR_GET_LONG(buf);
		}
		 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
			 return FALSE;
		 if (!xdr_double (xdrs, &objp->base_frequency))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->max_period))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->max_client_number))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->current_client_number))
				 return FALSE;

		} else {
		objp->max_period = IXDR_GET_LONG(buf);
		objp->max_client_number = IXDR_GET_LONG(buf);
		objp->current_client_number = IXDR_GET_LONG(buf);
		}
		 if (!xdr_TSP_status_t (xdrs, &objp->status))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->provider_timeout))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->provider_group_number))
		 return FALSE;
	 if (!xdr_TSP_sample_symbol_info_list_t (xdrs, &objp->symbols))
		 return FALSE;
	 if (!xdr_double (xdrs, &objp->base_frequency))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->max_period))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->max_client_number))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->current_client_number))
		 return FALSE;
	 if (!xdr_TSP_status_t (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_sample_init_t (XDR *xdrs, TSP_request_sample_init_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_sample_init_t (XDR *xdrs, TSP_answer_sample_init_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->data_address, ~0))
		 return FALSE;
	 if (!xdr_TSP_status_t (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_sample_destroy_t (XDR *xdrs, TSP_request_sample_destroy_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_sample_destroy_t (XDR *xdrs, TSP_answer_sample_destroy_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_async_sample_t (XDR *xdrs, TSP_async_sample_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->provider_global_index))
		 return FALSE;
	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_request_async_sample_t (XDR *xdrs, TSP_request_async_sample_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_TSP_async_sample_t (xdrs, &objp->async_sample))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_answer_async_sample_t (XDR *xdrs, TSP_answer_async_sample_t *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->version_id))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->channel_id))
		 return FALSE;
	 if (!xdr_TSP_async_sample_t (xdrs, &objp->async_sample))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->status))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_TSP_provider_info_t (XDR *xdrs, TSP_provider_info_t *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->info, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_tsp_request_filtered_information_1_argument (XDR *xdrs, tsp_request_filtered_information_1_argument *objp)
{
	 if (!xdr_TSP_request_information_t (xdrs, &objp->arg1))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->arg2))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->arg3, ~0))
		 return FALSE;
	return TRUE;
}
#define TSP_STRACE_RPC_ERROR(cl, pResult) if(!pResult) { STRACE_ERROR("%s", clnt_sperror(cl, "")); }
